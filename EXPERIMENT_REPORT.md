# Laravel vs Go API 效能比較實驗報告

**實驗日期**: 2026-01-21  
**實驗工具**: k6 負載測試工具  
**測試時長**: 302.3 秒 (約 5 分鐘)

---

## 📋 實驗目的

比較 Laravel (PHP-FPM + Nginx) 與 Go 在處理 I/O 密集型任務時的效能差異，特別是在高並發場景下的表現。

## 🔧 實驗環境

### 測試架構

```
┌─────────────┐      ┌──────────────┐
│   Go API    │─────→│  IO Service  │
│  (port 8081)│      │  (port 8080) │
└─────────────┘      └──────────────┘
                            ↑
┌─────────────┐            │
│ Laravel API │────────────┘
│ (port 9000) │
└─────────────┘
```

### 技術規格

| 項目 | Go API | Laravel API |
|------|--------|-------------|
| 語言/框架 | Go 1.22 | PHP 8.4 + Laravel 12 |
| Web 伺服器 | Go net/http | Nginx + PHP-FPM |
| 並發模型 | Goroutine | 進程池 (動態) |
| 最大並發數 | 理論上無限制 | 50 workers |
| 記憶體模型 | 輕量級 (~2KB/goroutine) | 中等 (~30-50MB/worker) |

### IO Service 規格
- 固定延遲: 1000ms
- 用途: 模擬資料庫查詢、外部 API 呼叫等 I/O 操作

## 📊 測試配置

### 負載測試場景

```javascript
stages: [
  { duration: '30s', target: 100 },   // 逐漸增加到 100 個並發用戶
  { duration: '1m',  target: 200 },   // 逐漸增加到 200 個並發用戶
  { duration: '2m',  target: 300 },   // 逐漸增加到 300 個並發用戶
  { duration: '1m',  target: 150 },   // 逐漸減少到 150 個並發用戶
  { duration: '30s', target: 0 },     // 逐漸減少到 0
]
```

### 測試指標
- 成功率 (Success Rate)
- 平均回應時間 (Average Response Time)
- 中位數回應時間 (Median)
- P95 回應時間 (95th Percentile)
- 最小/最大回應時間

## 📈 實驗結果

### 總體統計

| 指標 | 數值 |
|------|------|
| 總請求數 | 25,524 次 |
| 成功請求數 | 17,208 次 (67.4%) |
| 失敗請求數 | 8,316 次 (32.6%) |
| 測試時長 | 302.3 秒 |
| 最高並發數 | 300 個用戶 |

### Go API 效能表現

| 指標 | 數值 | 評價 |
|------|------|------|
| **成功率** | **100.0%** | ✅ 優秀 |
| **總請求數** | 12,762 次 | - |
| **失敗數** | 0 次 | ✅ 完美 |
| **平均回應時間** | 1,008.19 ms | ✅ 優秀 |
| **中位數** | 1,005 ms | ✅ 穩定 |
| **P90** | 1,013 ms | ✅ 穩定 |
| **P95** | 1,021 ms | ✅ 穩定 |
| **最小值** | 1,000 ms | - |
| **最大值** | 1,512 ms | ✅ 波動小 |

**分析**：
- ✅ 在 300 個並發用戶下，Go API 維持 100% 成功率
- ✅ 回應時間非常穩定，P95 僅比平均值高 12.8ms
- ✅ 最大回應時間 1,512ms，波動幅度僅 51.2%
- ✅ 即使在極高負載下，效能依然穩定

### Laravel API 效能表現

| 指標 | 數值 | 評價 |
|------|------|------|
| **成功率** | **34.84%** | ❌ 不及格 |
| **總請求數** | 12,762 次 | - |
| **成功數** | 4,446 次 | - |
| **失敗數** | 8,316 次 | ❌ 嚴重 |
| **平均回應時間** | 2,438.29 ms | ⚠️ 偏高 |
| **中位數** | 2,504 ms | ⚠️ 偏高 |
| **P90** | 3,908 ms | ⚠️ 很高 |
| **P95** | 4,102 ms | ❌ 過高 |
| **最小值** | 1,003 ms | - |
| **最大值** | 5,760 ms | ❌ 波動大 |

**分析**：
- ❌ 成功率僅 34.84%，超過 65% 的請求失敗
- ❌ 平均回應時間是 Go 的 2.42 倍
- ❌ P95 回應時間高達 4,102ms，是 Go 的 4.02 倍
- ❌ 最大回應時間 5,760ms，波動幅度達 474.6%
- ⚠️ PHP-FPM 50 個 worker 配置無法應對 300 並發

### 失敗原因分析

Laravel API 的失敗主要由以下原因造成：

1. **PHP-FPM Worker 數量限制**
   - 配置: `pm.max_children = 50`
   - 300 個並發遠超過 50 個 worker 的處理能力
   - 超過的請求需要排隊等待，導致超時

2. **請求排隊效應**
   - 當所有 50 個 worker 都在忙碌時
   - 新請求被迫等待，導致回應時間急劇增加
   - 部分請求等待超時（>2000ms 檢查失敗）

3. **連接超時**
   - 大量並發連接可能導致連接池耗盡
   - Nginx 連接限制或超時設定

## 📊 效能比較圖表

### 成功率對比

```
Go API:      ████████████████████████████████████████ 100.0%
Laravel API: █████████████▌                            34.8%
```

### 平均回應時間對比

```
Go API:      ████████████▊                           1,008ms
Laravel API: ███████████████████████████████▏        2,438ms
```

### P95 回應時間對比

```
Go API:      ████████████▊                           1,021ms
Laravel API: █████████████████████████████████████████████████ 4,102ms
```

## 🔍 深入分析

### 1. 並發處理能力

**Go API**:
- 使用 goroutine 實現並發
- 每個 goroutine 僅需 ~2KB 記憶體
- 可輕鬆處理數千個並發連接
- **結論**: 在 300 並發下游刃有餘

**Laravel API**:
- 使用 PHP-FPM 進程池
- 每個進程需 ~30-50MB 記憶體
- 最多 50 個並發進程
- **結論**: 在 300 並發下嚴重超載

### 2. 記憶體效率

| 項目 | Go API | Laravel API |
|------|--------|-------------|
| 單位記憶體 | ~2KB/goroutine | ~40MB/worker |
| 300 並發記憶體需求 | ~600KB | ~12GB (理論) |
| 實際配置 | 無限制 | 50 workers (~2GB) |

### 3. 回應時間穩定性

**標準差分析**:
- Go API: 回應時間高度一致，標準差極小
- Laravel API: 回應時間波動劇烈，標準差大

**原因**:
- Go: 每個請求獨立的 goroutine，不互相影響
- Laravel: Worker 數量有限，請求需要排隊

### 4. 擴展性分析

**Go API**:
- ✅ 水平擴展性優秀
- ✅ 可線性增加並發處理能力
- ✅ 記憶體開銷可控

**Laravel API**:
- ⚠️ 受限於 worker 數量
- ⚠️ 增加 worker 需要更多記憶體
- ⚠️ 記憶體開銷隨並發數線性增長

## 💡 優化建議

### Laravel API 優化方案

#### 方案 1: 增加 PHP-FPM Workers (短期)

```ini
# php-fpm.conf
pm.max_children = 200        # 從 50 提升到 200
pm.start_servers = 50        # 從 10 提升到 50
pm.min_spare_servers = 25    # 從 5 提升到 25
pm.max_spare_servers = 100   # 從 20 提升到 100
```

**效果預估**:
- 可處理並發數: 50 → 200
- 記憶體需求: ~2GB → ~8GB
- 成功率預估: 34.8% → ~66.7%

**限制**:
- 需要更多伺服器記憶體
- 仍無法完全匹敵 Go 的並發能力

#### 方案 2: 使用 Laravel Octane (推薦)

```bash
composer require laravel/octane
php artisan octane:install --server=swoole
```

**優勢**:
- 基於 Swoole 或 RoadRunner
- 應用程式常駐記憶體
- 效能提升 3-5 倍
- 並發能力大幅提升

**效果預估**:
- 平均回應時間: 2,438ms → ~800ms
- 可處理並發數: 大幅提升
- 成功率: 34.8% → >95%

#### 方案 3: 水平擴展

- 部署多個 Laravel 實例
- 使用負載均衡器 (Nginx/HAProxy)
- 分散請求到多台伺服器

### Go API 優化方案

Go API 已經表現優異，進一步優化空間：

1. **HTTP Client 連線池優化**
```go
client := &http.Client{
    Transport: &http.Transport{
        MaxIdleConns:        200,
        MaxIdleConnsPerHost: 200,
        IdleConnTimeout:     90 * time.Second,
    },
}
```

2. **Goroutine Pool**
- 限制最大 goroutine 數量
- 避免資源耗盡

3. **監控與告警**
- 記憶體使用監控
- 回應時間告警

## 📊 成本效益分析

### 資源成本 (估算)

| 方案 | 伺服器規格 | 月成本 | 可處理並發 |
|------|-----------|--------|-----------|
| Go (單機) | 2核4GB | $20 | 1000+ |
| Laravel (單機) | 8核16GB | $80 | ~200 |
| Laravel Octane | 4核8GB | $40 | 500+ |
| Laravel 叢集 (3台) | 3×4核8GB | $120 | 600+ |

### ROI 分析

**Go API**:
- ✅ 最低的硬體需求
- ✅ 最高的效能/成本比
- ✅ 最簡單的部署和維護

**Laravel API**:
- ⚠️ 需要更多硬體資源
- ✅ 豐富的生態系統
- ✅ 更快的開發速度

## 🎯 結論

### 實驗結論

1. **並發能力**: Go >>> Laravel (傳統 PHP-FPM)
   - Go: 300 並發 100% 成功率
   - Laravel: 300 並發 34.8% 成功率

2. **回應時間**: Go > Laravel
   - Go: 平均 1,008ms，穩定
   - Laravel: 平均 2,438ms，波動大

3. **資源效率**: Go >>> Laravel
   - Go: 低記憶體，高效能
   - Laravel: 高記憶體，效能受限

4. **穩定性**: Go >>> Laravel
   - Go: P95 僅比平均值高 1.3%
   - Laravel: P95 比平均值高 68.2%

### 適用場景建議

**選擇 Go 的場景**:
- ✅ 高並發需求 (1000+ QPS)
- ✅ 微服務架構
- ✅ 即時系統
- ✅ I/O 密集型任務
- ✅ 資源受限環境

**選擇 Laravel 的場景**:
- ✅ 中低並發需求 (<100 QPS)
- ✅ 快速原型開發
- ✅ 內容管理系統
- ✅ 團隊熟悉 PHP
- ✅ 需要豐富的生態系統

**Laravel 最佳化建議**:
- 使用 Laravel Octane (Swoole)
- 增加 PHP-FPM workers
- 水平擴展
- 使用快取層 (Redis)

### 最終建議

對於 I/O 密集型、高並發的 API 服務：
- **首選**: Go
- **次選**: Laravel + Octane
- **不推薦**: 傳統 PHP-FPM (在高並發場景下)

## 📚 參考資料

- [k6 負載測試工具](https://k6.io/)
- [PHP-FPM 配置指南](https://www.php.net/manual/en/install.fpm.configuration.php)
- [Laravel Octane 文件](https://laravel.com/docs/octane)
- [Go net/http 套件](https://pkg.go.dev/net/http)

---

**報告產生時間**: 2026-01-21  
**測試環境**: Docker 容器化環境  
**數據來源**: k6 測試結果 (summary.json)
